import OpenAI from "openai";
import type { RequestContext } from "../types/ai.js";
import { getSupabaseServiceClient } from "../utils/supabaseClient.js";

/**
 * Servi√ßo para gest√£o de atas
 * Implementa as APIs conforme especificado no PRD
 */
export class MinutesService {
  private openaiRouter: OpenAI;
  private supabase = getSupabaseServiceClient();

  constructor() {
    const openRouterKey = process.env.OPENROUTER_API_KEY;
    if (!openRouterKey) {
      throw new Error("OPENROUTER_API_KEY environment variable is required");
    }

    this.openaiRouter = new OpenAI({
      baseURL: "https://openrouter.ai/api/v1",
      apiKey: openRouterKey,
      defaultHeaders: {
        "HTTP-Referer": process.env.SITE_URL || "http://localhost:3000",
        "X-Title": process.env.SITE_NAME || "CondoGov API",
      },
    });
  }

  /**
   * Gera ata de assembleia
   */
  async generateMinutesFromAssembly(assemblyId: string, data: any, context: RequestContext) {
    try {
      // 1. Buscar dados da assembleia
      const assembly = await this.getAssemblyFromDatabase(assemblyId, context.companyId);
      if (!assembly) {
        throw new Error("Assembleia n√£o encontrada");
      }

      // 2. Buscar transcri√ß√£o
      const transcription = await this.getTranscriptionFromDatabase(assemblyId, context.companyId);

      // 3. Gerar ata com IA
      const minutesContent = await this.generateMinutesContent(transcription, assembly, data);

      // 4. Salvar ata
      const minuteId = await this.saveMinute({
        companyId: context.companyId,
        assemblyId,
        title: assembly.title,
        content: minutesContent,
        format: data.format,
        isAutoGenerated: data.aiSummary,
        createdBy: context.userId,
      });

      // 5. Processar assinatura se solicitada
      let document = null;
      if (data.sendForSignature && data.signers) {
        document = await this.createSignatureDocument(minuteId, minutesContent, data.signers, context);
      }

      return {
        assemblyMinuteId: minuteId,
        content: minutesContent,
        document,
      };
    } catch (error) {
      console.error("Error generating minutes from assembly:", error);
      throw error;
    }
  }

  /**
   * Gera ata de grava√ß√£o
   */
  async generateMinutesFromRecording(recordingId: string, data: any, context: RequestContext) {
    try {
      // 1. Buscar dados da grava√ß√£o
      const recording = await this.getRecordingFromDatabase(recordingId, context.companyId);
      if (!recording) {
        throw new Error("Grava√ß√£o n√£o encontrada");
      }

      // 2. Buscar transcri√ß√£o
      const transcription = await this.getTranscriptionFromRecording(recordingId, context.companyId);

      // 3. Gerar ata com IA
      const minutesContent = await this.generateMinutesContent(transcription, recording, data);

      // 4. Salvar ata
      const minuteId = await this.saveMinute({
        companyId: context.companyId,
        recordingId,
        title: recording.roomName || "Ata de Grava√ß√£o",
        content: minutesContent,
        format: data.format,
        isAutoGenerated: data.aiSummary,
        createdBy: context.userId,
      });

      return {
        assemblyMinuteId: minuteId,
        content: minutesContent,
      };
    } catch (error) {
      console.error("Error generating minutes from recording:", error);
      throw error;
    }
  }

  /**
   * Lista assembleias dispon√≠veis
   */
  async getAvailableAssemblies(companyId: string, filters: any = {}) {
    try {
      const assemblies = await this.getAssembliesFromDatabase(companyId, filters);
      return assemblies;
    } catch (error) {
      console.error("Error getting available assemblies:", error);
      throw error;
    }
  }

  /**
   * Lista atas
   */
  async getMinutes(companyId: string, filters: any = {}) {
    try {
      const minutes = await this.getMinutesFromDatabase(companyId, filters);
      return minutes;
    } catch (error) {
      console.error("Error getting minutes:", error);
      throw error;
    }
  }

  /**
   * Busca ata espec√≠fica
   */
  async getMinute(minuteId: string, companyId: string) {
    try {
      const minute = await this.getMinuteFromDatabase(minuteId, companyId);
      return minute;
    } catch (error) {
      console.error("Error getting minute:", error);
      throw error;
    }
  }

  /**
   * Adiciona assinantes
   */
  async addSigners(minuteId: string, signers: any[], context: RequestContext) {
    try {
      const result = await this.saveSigners(minuteId, signers, context);
      return result;
    } catch (error) {
      console.error("Error adding signers:", error);
      throw error;
    }
  }

  /**
   * Envia lembretes
   */
  async sendReminders(minuteId: string, context: RequestContext) {
    try {
      const result = await this.sendRemindersToSigners(minuteId, context);
      return result;
    } catch (error) {
      console.error("Error sending reminders:", error);
      throw error;
    }
  }

  /**
   * Download PDF
   */
  async downloadPdf(minuteId: string, companyId: string) {
    try {
      const minute = await this.getMinuteFromDatabase(minuteId, companyId);
      if (!minute) {
        return null;
      }

      // Gerar PDF (simulado)
      const pdfBuffer = await this.generatePdf(minute.content, minute.title);
      
      return {
        buffer: pdfBuffer,
        filename: `${minute.title.replace(/[^a-zA-Z0-9]/g, '-')}.pdf`,
      };
    } catch (error) {
      console.error("Error downloading PDF:", error);
      throw error;
    }
  }

  /**
   * Gera conte√∫do da ata com IA
   */
  private async generateMinutesContent(transcription: any, source: any, options: any): Promise<string> {
    try {
      const systemPrompt = `Voc√™ √© um especialista em cria√ß√£o de atas de assembleia condominial.

FORMATO: ${options.format}
USAR IA: ${options.aiSummary ? 'Sim' : 'N√£o'}

Crie uma ata estruturada e profissional baseada na transcri√ß√£o fornecida.
Use linguagem formal e t√©cnica apropriada para documentos jur√≠dicos.`;

      const userPrompt = `Gere uma ata para:

FONTE: ${source.title || source.roomName}
TRANSCRI√á√ÉO: ${transcription.transcript || transcription.text}

Formate no formato ${options.format} solicitado.`;

      const completion = await this.openaiRouter.chat.completions.create({
        model: "openai/gpt-5-chat",
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt },
        ],
        temperature: 0.3,
        max_tokens: 4000,
      });

      return completion.choices[0]?.message?.content || "";
    } catch (error) {
      console.error("Error generating minutes content:", error);
      throw error;
    }
  }

  /**
   * Cria documento para assinatura
   */
  private async createSignatureDocument(minuteId: string, content: string, signers: any[], context: RequestContext) {
    try {
      // Gerar PDF
      const pdfBuffer = await this.generatePdf(content, "Ata de Assembleia");
      
      // Converter para base64
      const pdfBase64 = pdfBuffer.toString('base64');
      
      // Criar documento no Autentique (simulado)
      const document = {
        id: `doc_${Date.now()}`,
        name: "Ata de Assembleia",
        signers: signers.map((signer, index) => ({
          ...signer,
          order: index + 1,
        })),
        status: "pending",
        created_at: new Date().toISOString(),
      };

      console.log(`üìù Signature document created (simulated): ${document.id}`);
      
      return document;
    } catch (error) {
      console.error("Error creating signature document:", error);
      throw error;
    }
  }

  /**
   * Gera PDF (simulado)
   */
  private async generatePdf(content: string, title: string): Promise<Buffer> {
    // Simular gera√ß√£o de PDF
    const mockPdfContent = `%PDF-1.4
1 0 obj
<<
/Type /Catalog
/Pages 2 0 R
>>
endobj

2 0 obj
<<
/Type /Pages
/Kids [3 0 R]
/Count 1
>>
endobj

3 0 obj
<<
/Type /Page
/Parent 2 0 R
/MediaBox [0 0 612 792]
/Contents 4 0 R
>>
endobj

4 0 obj
<<
/Length 44
>>
stream
BT
/F1 12 Tf
72 720 Td
(${title}) Tj
ET
endstream
endobj

xref
0 5
0000000000 65535 f 
0000000009 00000 n 
0000000058 00000 n 
0000000115 00000 n 
0000000204 00000 n 
trailer
<<
/Size 5
/Root 1 0 R
>>
startxref
297
%%EOF`;

    return Buffer.from(mockPdfContent);
  }

  /**
   * Salva ata no banco
   */
  private async saveMinute(data: any): Promise<string> {
    const minuteId = `minute_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    console.log(`üíæ Minute saved (simulated): ${minuteId}`);
    return minuteId;
  }

  /**
   * Salva assinantes no banco
   */
  private async saveSigners(minuteId: string, signers: any[], context: RequestContext) {
    console.log(`üíæ Signers saved (simulated): ${signers.length} signers for minute ${minuteId}`);
    return {
      minuteId,
      signers: signers.map((signer, index) => ({
        id: `signer_${Date.now()}_${index}`,
        ...signer,
        status: "pending",
        created_at: new Date().toISOString(),
      })),
    };
  }

  /**
   * Envia lembretes para assinantes
   */
  private async sendRemindersToSigners(minuteId: string, context: RequestContext) {
    console.log(`üìß Reminders sent (simulated): for minute ${minuteId}`);
    return {
      minuteId,
      remindersSent: 3,
      status: "sent",
    };
  }

  /**
   * Busca assembleia no banco
   */
  private async getAssemblyFromDatabase(assemblyId: string, companyId: string): Promise<any> {
    // Simular busca
    return {
      id: assemblyId,
      title: "Assembleia Ordin√°ria - Janeiro 2025",
      description: "Assembleia para aprova√ß√£o de or√ßamento",
      scheduled_date: "2025-01-25T14:00:00Z",
      location: "Sal√£o de festas",
      status: "realizada",
      client_id: 1,
      company_id: companyId,
    };
  }

  /**
   * Busca grava√ß√£o no banco
   */
  private async getRecordingFromDatabase(recordingId: string, companyId: string): Promise<any> {
    // Simular busca
    return {
      id: recordingId,
      room_id: "assembly-123",
      room_name: "Assembleia Janeiro 2025",
      file_path: "/recordings/assembly_123.mp3",
      file_size: 15728640,
      duration: 630,
      status: "completed",
      company_id: companyId,
    };
  }

  /**
   * Busca transcri√ß√£o no banco
   */
  private async getTranscriptionFromDatabase(assemblyId: string, companyId: string): Promise<any> {
    // Simular busca
    return {
      id: `trans_${assemblyId}`,
      assembly_id: assemblyId,
      transcript: "Transcri√ß√£o completa da assembleia...",
      status: "completed",
      confidence: 0.91,
    };
  }

  /**
   * Busca transcri√ß√£o de grava√ß√£o no banco
   */
  private async getTranscriptionFromRecording(recordingId: string, companyId: string): Promise<any> {
    // Simular busca
    return {
      id: `trans_${recordingId}`,
      recording_id: recordingId,
      text: "Transcri√ß√£o completa da grava√ß√£o...",
      status: "completed",
      confidence: 0.91,
    };
  }

  /**
   * Busca assembleias no banco
   */
  private async getAssembliesFromDatabase(companyId: string, filters: any): Promise<any[]> {
    // Simular busca
    return [
      {
        id: 1,
        title: "Assembleia Ordin√°ria - Janeiro 2025",
        description: "Assembleia para aprova√ß√£o de or√ßamento",
        scheduled_date: "2025-01-25T14:00:00Z",
        location: "Sal√£o de festas",
        status: "realizada",
        client_id: 1,
      },
      {
        id: 2,
        title: "Assembleia Extraordin√°ria - Fevereiro 2025",
        description: "Assembleia para elei√ß√£o de s√≠ndico",
        scheduled_date: "2025-02-15T14:00:00Z",
        location: "Virtual",
        status: "agendada",
        client_id: 1,
      },
    ];
  }

  /**
   * Busca atas no banco
   */
  private async getMinutesFromDatabase(companyId: string, filters: any): Promise<any[]> {
    // Simular busca
    return [
      {
        id: 1,
        title: "Ata da Assembleia Ordin√°ria - Janeiro 2025",
        content: "Conte√∫do da ata...",
        status: "finalizada",
        is_auto_generated: true,
        created_at: "2025-01-25T16:00:00Z",
        assembly: {
          id: 1,
          title: "Assembleia Ordin√°ria - Janeiro 2025",
          scheduled_date: "2025-01-25T14:00:00Z",
        },
        signatures: {
          total: 3,
          signed: 3,
          pending: 0,
        },
      },
    ];
  }

  /**
   * Edita ATA com IA
   */
  async editMinutesWithAI(minuteId: string, data: any, context: RequestContext) {
    try {
      console.log("[Minutes] Iniciando edi√ß√£o de ATA com IA");
      console.log("[Minutes] ATA ID:", minuteId);
      console.log("[Minutes] Tipo de edi√ß√£o:", data.editType);
      console.log("[Minutes] Se√ß√µes alvo:", data.targetSections || "todas");

      // 1. Buscar ata atual
      const currentMinute = await this.getMinuteFromDatabase(minuteId, context.companyId);
      if (!currentMinute) {
        throw new Error("Ata n√£o encontrada");
      }

      console.log("[Minutes] ATA encontrada, tamanho atual:", currentMinute.content?.length || 0, "caracteres");

      // 2. Gerar edi√ß√£o com IA
      const editedContent = await this.generateEditWithAI(
        currentMinute.content,
        data,
        context
      );

      console.log("[Minutes] Edi√ß√£o gerada, novo tamanho:", editedContent.length, "caracteres");

      // 3. Atualizar ata no banco
      // N√£o passar format se n√£o existir na tabela (ser√° tratado no m√©todo)
      const updatedMinute = await this.updateMinuteInDatabase(
        minuteId,
        {
          content: editedContent,
          format: currentMinute.format || data.format || "markdown", // Tentar usar, mas pode n√£o existir
          editedBy: context.userId,
          editType: data.editType,
          editInstructions: data.instructions,
        },
        context.companyId
      );

      // 4. Gerar arquivo atualizado se necess√°rio
      let fileUrl: string | undefined = undefined;
      if (currentMinute.format === "pdf" || currentMinute.format === "word" || data.format === "pdf" || data.format === "word") {
        console.log("[Minutes] Gerando arquivo atualizado...");
        // Aqui voc√™ pode chamar um m√©todo para gerar PDF/Word atualizado
        // fileUrl = await this.generateFile(editedContent, format, title, companyId);
      }

      return {
        minuteId: updatedMinute.id || minuteId, // Usar ID atualizado ou original
        content: editedContent,
        format: updatedMinute.format || currentMinute.format || data.format || "markdown",
        fileUrl,
        changes: {
          editType: data.editType,
          sectionsEdited: data.targetSections || "todas",
          originalLength: currentMinute.content?.length || 0,
          newLength: editedContent.length,
          difference: editedContent.length - (currentMinute.content?.length || 0),
        },
        usage: {
          // Tokens ser√£o calculados no m√©todo generateEditWithAI
        },
      };
    } catch (error) {
      console.error("Error editing minutes with AI:", error);
      throw error;
    }
  }

  /**
   * Gera edi√ß√£o da ATA usando IA
   */
  private async generateEditWithAI(
    currentContent: string,
    editOptions: any,
    context: RequestContext
  ): Promise<string> {
    try {
      console.log("[Minutes] Gerando edi√ß√£o com IA...");

      const editTypePrompts = {
        improve: `Melhore a qualidade do texto da ata, tornando-o mais claro, profissional e bem estruturado. 
Mantenha todas as informa√ß√µes originais, mas aprimore a linguagem, organiza√ß√£o e clareza.
Use linguagem formal e t√©cnica apropriada para documentos jur√≠dicos.
Preserve a estrutura e todas as se√ß√µes existentes.`,

        correct: `Corrija todos os erros gramaticais, ortogr√°ficos e de pontua√ß√£o na ata.
Mantenha o conte√∫do exatamente como est√°, apenas corrigindo erros.
N√£o altere o significado ou estrutura do texto.
Preserve a formata√ß√£o original.`,

        expand: `Expanda as se√ß√µes especificadas da ata, adicionando mais detalhes e informa√ß√µes relevantes.
Mantenha fidelidade ao conte√∫do original, mas adicione mais profundidade e contexto.
Use linguagem formal e t√©cnica.
Preserve a estrutura geral da ata.`,

        summarize: `Resuma as se√ß√µes muito longas da ata, mantendo apenas as informa√ß√µes essenciais.
Mantenha todas as decis√µes, vota√ß√µes e pontos importantes.
Remova redund√¢ncias e informa√ß√µes desnecess√°rias.
Preserve a estrutura e formata√ß√£o.`,

        add_section: `Adicione uma nova se√ß√£o √† ata conforme as instru√ß√µes fornecidas.
A nova se√ß√£o deve seguir o mesmo padr√£o formal e t√©cnico das se√ß√µes existentes.
Integre a nova se√ß√£o de forma natural na estrutura da ata.
Mantenha todas as se√ß√µes originais intactas.`,

        reformat: `Reformate a estrutura da ata para melhor organiza√ß√£o e legibilidade.
Mantenha todo o conte√∫do original, apenas reorganizando e melhorando a estrutura.
Use formata√ß√£o consistente em todas as se√ß√µes.
Preserve todas as informa√ß√µes importantes.`,

        custom: editOptions.instructions || "Edite a ata conforme necess√°rio.",
      };

      const editType = editOptions.editType as keyof typeof editTypePrompts;
      const basePrompt = editTypePrompts[editType] || editTypePrompts.improve;

      // Construir prompt espec√≠fico
      let specificInstructions = basePrompt;
      
      if (editOptions.targetSections && editOptions.targetSections.length > 0) {
        specificInstructions += `\n\nFOCAR APENAS NAS SEGUINTES SE√á√ïES: ${editOptions.targetSections.join(", ")}`;
        specificInstructions += `\nMantenha as outras se√ß√µes inalteradas.`;
      }

      if (editOptions.instructions && editOptions.editType !== "custom") {
        specificInstructions += `\n\nINSTRU√á√ïES ADICIONAIS: ${editOptions.instructions}`;
      }

      const systemPrompt = `Voc√™ √© um especialista em edi√ß√£o de atas de assembleia condominial.

TAREFA: ${specificInstructions}

REQUISITOS:
- Use linguagem formal e t√©cnica jur√≠dica
- Mantenha a estrutura de documento oficial
- Preserve todas as informa√ß√µes importantes
- Seja preciso e fiel ao conte√∫do original
- ${editOptions.preserveFormat ? "Preserve a formata√ß√£o original" : "Melhore a formata√ß√£o se necess√°rio"}
- Idioma: ${editOptions.language || "pt-BR"}

IMPORTANTE: Voc√™ est√° editando uma ATA OFICIAL. Seja cuidadoso para n√£o alterar o significado ou perder informa√ß√µes importantes.`;

      const userPrompt = `Edite a seguinte ATA conforme as instru√ß√µes:

ATA ORIGINAL:
"${currentContent.substring(0, 30000)}"

${editOptions.targetSections && editOptions.targetSections.length > 0 
  ? `\nFOCAR APENAS NAS SE√á√ïES: ${editOptions.targetSections.join(", ")}`
  : ""
}

Retorne a ATA editada completa, mantendo a estrutura e formata√ß√£o apropriada.`;

      console.log("[Minutes] Enviando requisi√ß√£o para IA...");
      const startTime = Date.now();

      const completion = await this.openaiRouter.chat.completions.create({
        model: "openai/gpt-5-chat",
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt },
        ],
        temperature: 0.3, // Baixo para manter precis√£o
        max_tokens: 8000, // Permitir atas longas
      });

      const elapsedTime = Date.now() - startTime;
      const editedContent = completion.choices[0]?.message?.content || "";
      
      console.log("[Minutes] Edi√ß√£o gerada em", elapsedTime, "ms");
      console.log("[Minutes] Tokens usados:", completion.usage?.total_tokens || 0);
      console.log("[Minutes] Tamanho do conte√∫do editado:", editedContent.length, "caracteres");

      return editedContent;
    } catch (error) {
      console.error("[Minutes] Erro ao gerar edi√ß√£o com IA:", error);
      throw error;
    }
  }

  /**
   * Atualiza ata no banco de dados
   */
  private async updateMinuteInDatabase(
    minuteId: string,
    data: {
      content: string;
      format?: string;
      editedBy: string;
      editType: string;
      editInstructions?: string;
    },
    companyId: string
  ): Promise<any> {
    try {
      console.log("[Minutes] Atualizando ATA no banco de dados...");
      
      // Payload b√°sico SEM format (pode n√£o existir na tabela)
      const payload: any = {
        content: data.content,
        updated_at: new Date().toISOString(),
      };
      
      console.log("[Minutes] Payload b√°sico (sem format):", Object.keys(payload));

      // Tentar adicionar campos de edi√ß√£o (podem n√£o existir na tabela)
      const editFields = [
        { edited_by: data.editedBy },
        { user_id: data.editedBy },
        { edited_by_user: data.editedBy },
      ];

      // Tentar diferentes combina√ß√µes de campos
      // Primeiro tentar sem format (pode n√£o existir na tabela)
      let updateSuccess = false;
      
      for (const fields of editFields) {
        try {
          const testPayload = { ...payload, ...fields };
          // N√£o adicionar format, edit_type, edit_instructions se n√£o existirem
          // Tentar adicionar apenas se n√£o der erro
          
          const { data: updated, error } = await this.supabase
            .from("minutes")
            .update(testPayload)
            .eq("id", minuteId)
            .eq("company_id", companyId)
            .select("*")
            .maybeSingle();

          if (error && error.code === "PGRST204") {
            // Coluna n√£o existe, tentar pr√≥xima varia√ß√£o
            console.log(`[Minutes] Coluna n√£o encontrada (${error.message}), tentando pr√≥xima varia√ß√£o...`);
            continue;
          }

          if (error) throw error;

          if (updated) {
            console.log("[Minutes] ‚úÖ ATA atualizada com sucesso no banco");
            return updated;
          }
          updateSuccess = true;
          break;
        } catch (updateError: any) {
          if (updateError.code !== "PGRST204") {
            throw updateError;
          }
          console.log(`[Minutes] Erro PGRST204, tentando pr√≥xima varia√ß√£o...`);
          continue;
        }
      }

      // Se todas as tentativas falharam, tentar apenas com campos b√°sicos
      if (!updateSuccess) {
        console.log("[Minutes] Tentando atualizar apenas com campos b√°sicos...");
        const { data: updated, error } = await this.supabase
          .from("minutes")
          .update(payload)
          .eq("id", minuteId)
          .eq("company_id", companyId)
          .select("*")
          .maybeSingle();

        if (error) throw error;
        if (!updated) throw new Error("ATA n√£o encontrada para atualiza√ß√£o");

        console.log("[Minutes] ‚úÖ ATA atualizada com sucesso (apenas campos b√°sicos)");
        return updated;
      }

      throw new Error("N√£o foi poss√≠vel atualizar a ATA");
    } catch (error) {
      console.error("[Minutes] Erro ao atualizar ATA:", error);
      throw error;
    }
  }

  /**
   * Busca ata espec√≠fica no banco
   */
  private async getMinuteFromDatabase(minuteId: string, companyId: string): Promise<any> {
    try {
      console.log("[Minutes] Buscando ATA no banco, ID:", minuteId, "Company:", companyId);
      
      const { data, error } = await this.supabase
        .from("minutes")
        .select("*")
        .eq("id", minuteId)
        .eq("company_id", companyId)
        .maybeSingle();

      if (error) {
        console.error("[Minutes] Erro ao buscar ATA:", error);
        throw error;
      }

      if (!data) {
        console.log("[Minutes] ATA n√£o encontrada no banco");
        return null;
      }

      console.log("[Minutes] ‚úÖ ATA encontrada no banco, ID:", data.id);
      console.log("[Minutes] T√≠tulo:", data.title);
      console.log("[Minutes] Tamanho do conte√∫do:", data.content?.length || 0, "caracteres");
      
      return data;
    } catch (error) {
      console.error("[Minutes] Erro ao buscar ATA do banco:", error);
      throw error;
    }
  }
}
